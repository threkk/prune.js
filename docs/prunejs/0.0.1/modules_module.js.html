<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>modules/module.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AbstractAnalyser.html">AbstractAnalyser</a></li><li><a href="AbstractIssue.html">AbstractIssue</a></li><li><a href="AST.html">AST</a></li><li><a href="Config.html">Config</a></li><li><a href="DependenciesAnalyser.html">DependenciesAnalyser</a><ul class='methods'><li data-type='method'><a href="DependenciesAnalyser.html#analyse">analyse</a></li></ul></li><li><a href="DependencyIssue.html">DependencyIssue</a></li><li><a href="ErrorIssue.html">ErrorIssue</a></li><li><a href="Logger.html">Logger</a><ul class='methods'><li data-type='method'><a href="Logger.html#displayCode">displayCode</a></li><li data-type='method'><a href="Logger.html#displayDependencies">displayDependencies</a></li><li data-type='method'><a href="Logger.html#displayErrors">displayErrors</a></li><li data-type='method'><a href="Logger.html#displayModules">displayModules</a></li><li data-type='method'><a href="Logger.html#report">report</a></li></ul></li><li><a href="Module.html">Module</a><ul class='methods'><li data-type='method'><a href="Module.html#._extractPath">_extractPath</a></li><li data-type='method'><a href="Module.html#._importParser">_importParser</a></li><li data-type='method'><a href="Module.html#.create">create</a></li></ul></li><li><a href="ModuleIssue.html">ModuleIssue</a></li><li><a href="ModulesAnalyser.html">ModulesAnalyser</a><ul class='methods'><li data-type='method'><a href="ModulesAnalyser.html#analyse">analyse</a></li></ul></li><li><a href="Project.html">Project</a><ul class='methods'><li data-type='method'><a href="Project.html#.isValidPath">isValidPath</a></li><li data-type='method'><a href="Project.html#_files">_files</a></li><li data-type='method'><a href="Project.html#analyse">analyse</a></li><li data-type='method'><a href="Project.html#execute">execute</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#DependencyType">DependencyType</a></li><li><a href="global.html#ModuleCase">ModuleCase</a></li><li><a href="global.html#Type">Type</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">modules/module.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { dirname, extname, isAbsolute, resolve } = require('path')
const { existsSync } = require('fs')

const AST = require('../project/ast')

/**
 * Defines the relevant information for handling modules: the path to the
 * module, the other modules it imports and if it exports something (what it
 * exports is irrelevant because we are not taking that into consideration in
 * this sections).
 */
class Module {
  /**
   * @constructor
   * @param {string} filePath - Path to the module.
   * @param {array} uses - Array containing the list of paths of other modules
   * it uses.
   * @param {boolean} isExported - If the module exports something or not.
   */
  constructor (filePath, uses, isExported) {
    this._filePath = filePath
    this._isExported = isExported
    this._uses = uses
  }

  /** @return {string} Path to the module. */
  get filePath () {
    return this._filePath
  }

  /** @return {boolean} If the module exports something or not */
  get isExported () {
    return this._isExported
  }

  /** @return {array} List of paths that the module uses. */
  get uses () {
    return this._uses
  }

  /**
   * Static function used to create modules.
   *
   * This function will generate the AST tree and look for the `require`
   * (CommonJS) function and `import` (ES6) keyword to determine which other
   * modules are used by the given module. It will also look for the
   * `module.exports` and `export` statements to determine if it export any of
   * its definitions.
   *
   * @static
   * @param {string} filePath - Path to the module.
   * @param {boolean} withES7 - If the AST should be generated with ES7 support.
   * @param {boolean} withJSX - If the AST should be generated with JSX support.
   * @return {Module} Module based on the content of the file path.
   * @throws {Error} If the AST could not be generated.
   */
  static create (filePath, withES7, withJSX) {
    const ast = new AST(filePath, withES7, withJSX)
    const isValidBody =
      ast != null &amp;&amp;
      ast.ast != null &amp;&amp;
      ast.ast.program != null &amp;&amp;
      ast.ast.program.body != null &amp;&amp;
      Array.isArray(ast.ast.program.body)

    if (isValidBody) {
      const uses = []
      let isExported = false

      for (let element of ast.ast.program.body) {
        switch (element.type) {
          case 'VariableDeclaration':
            const req = this._declarationParser(element, filePath, withJSX)
            if (req != null) uses.push(req)
            break

          case 'ImportDeclaration':
            const imp = this._importParser(element, filePath, withJSX)
            if (imp != null) uses.push(imp)
            break

          case 'ExpressionStatement':
            const isModuleExportExpr =
              element.expression != null &amp;&amp;
              element.expression.type === 'AssignmentExpression' &amp;&amp;
              element.expression.left != null &amp;&amp;
              element.expression.left.type === 'MemberExpression' &amp;&amp;
              element.expression.left.object != null &amp;&amp;
              element.expression.left.object.type === 'Identifier' &amp;&amp;
              element.expression.left.object.name === 'module' &amp;&amp;
              element.expression.left.property.type === 'Identifier' &amp;&amp;
              element.expression.left.property.name === 'exports'

            isExported = isExported || isModuleExportExpr
            break

          case 'ExportNamedDeclaration':
            const isNotNullDeclaration = element.declaration != null
            const isNotNullSource = element.source != null
            const isNotEmptySpecifier =
              element.specifiers != null &amp;&amp;
              Array.isArray(element.specifiers) &amp;&amp;
              element.specifiers.length > 0

            if (isNotNullDeclaration &amp;&amp; (isNotNullSource || isNotEmptySpecifier)) {
              const file = element.loc.filename
              const start = element.loc.start
              const end = element.loc.end
              throw Error(`Invalid state detected at: ${file}:${start},${end}`)
            }

            isExported = true
            break

          case 'ExportDefaultDeclaration':
          case 'ExportAllDeclaration':
            isExported = true
            break
        }
      }
      return new Module(filePath, uses, isExported)
    }
  }

  /**
   * Given a `VariableDeclaration`, it checks if it fulfills the
   * [specifications](http://wiki.commonjs.org/wiki/Modules/1.1)  of a
   * `require` call. Sadly, this implementation has two issues:
   *
   * - Due to the dynamic nature of JavaScript, we cannot check using static
   *   analysis if the parameter of the require function is a `string` unless it
   *   is a `StringLiteral`. This issue has no good solution.
   *
   * - If the `require` function is assigned to a different variable, and that
   *   variable used to import the modules, it is not tracked.
   *
   * @static
   * @private
   * @param {Object} decl - AST node with type `VariableDeclaration`.
   * @param {string} filePath - Path to the root of the project.
   * @param {boolean} withJSX - If we should allow `.jsx` extensions.
   * @return {string} Path to the module declared in the require. `null` if it
   * is not a valid `require`.
   */
  static _declarationParser (decl, filePath, withJSX) {
    // Maybe we want to go back to the for statement, but it seems it is only
    // for AMD modules. This checks that it is a function called require that
    // accepts only one parameter.
    const isRequire =
      Array.isArray(decl.declarations) &amp;&amp;
      decl.declarations.length === 1 &amp;&amp;
      decl.declarations[0].init != null &amp;&amp;
      decl.declarations[0].init.callee != null &amp;&amp;
      decl.declarations[0].init.arguments != null &amp;&amp;
      decl.declarations[0].init.callee.name != null &amp;&amp;
      decl.declarations[0].init.callee.name === 'require' &amp;&amp;
      decl.declarations[0].init.arguments != null &amp;&amp;
      Array.isArray(decl.declarations[0].init.arguments) &amp;&amp;
      decl.declarations[0].init.arguments.length === 1

    const isRequireWithStr =
      isRequire &amp;&amp;
      decl.declarations[0].init.arguments[0].type === 'StringLiteral' &amp;&amp;
      decl.declarations[0].init.arguments[0].value != null

    if (isRequireWithStr) {
      const param = decl.declarations[0].init.arguments[0].value
      return this._extractPath(param, filePath, withJSX)
    }

    return null
  }

  /**
   * Given a `ImportDeclaration`, it extracts the path to the imported module.
   * In case the path is not valid, it will return null.
   *
   * @param {Object} element - AST node object with type `ImportDeclaration`.
   * @param {string} filePath - Path to the root of the project.
   * @param {boolean} withJSX - If we should allow `.jsx` extensions.
   * @return {string} Path to the module declared in the require. `null` if it
   * is not a valid `require`.
   */
  static _importParser (element, filePath, withJSX) {
    const isValidImport =
      element.source != null &amp;&amp;
      element.source.type === 'StringLiteral' &amp;&amp;
      element.source.value != null

    if (isValidImport) {
      const param = element.source.value
      return this._extractPath(param, filePath, withJSX)
    }

    return null
  }

  /**
   * Given a relative path as a string and the root of the project, resolves the
   * path to the module. In case it does not exist, it returns null.
   *
   * @param {string} value - Path to resolve.
   * @param {string} filePath - Path to the root of the project.
   * @param {boolean} withJSX - If we should allow `.jsx` extensions.
   * @return {string} Path to the module. Null if not found.
   */
  static _extractPath (value, filePath, withJSX) {
    const isAbsOrRel = (p) => ['.', '/'].includes(p.charAt(0))

    if (isAbsOrRel(value)) {
      let modulePath = value

      if (!isAbsolute(value)) {
        modulePath = resolve(dirname(filePath), value)
      }

      if (existsSync(modulePath)) {
        return modulePath
      } else if (extname(modulePath) === '') {
        if (existsSync(`${modulePath}.js`)) {
          return `${modulePath}.js`
        } else if (withJSX &amp;&amp; existsSync(`${modulePath}.jsx`)) {
          return `${modulePath}.jsx`
        }
      }
    }
    return null
  }
}

module.exports = Module
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon May 29 2017 09:35:35 GMT+0200 (CEST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
